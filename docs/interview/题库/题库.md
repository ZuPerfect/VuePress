## 📚 Javascript

### 1、如何直接在原数组里面删除偶数？注：直接在原数组上操作，不产生新的数组！（@sw）

### 2、说下 JS 中的事件循环机制

JS 的任务分为同步任务和异步任务：

- 任务队列分为同步任务队列和异步任务队列；
- 代码执行时，遇到同步代码，会被直接推入同步任务队列并依次执行；
- 遇到异步代码（如 setTimeout、setInteval）会被直接推入异步任务队列；
- 当同步任务队列执行完毕，这个时候异步任务队列的任务会被一次推入同步任务队列并依次执行

JS 的任务队列分为：
宏任务：setTimeout setInterval
微任务：Promise.then 方法。注意 new Promise()的时候是同步的，会立即执行。
注意：现在有三个队列：同步队列（也称为执行栈）、宏任务队列、微任务队列
所以，针对这种机制，js 的事件循环机制应该是这样的：

- 遇到同步代码，依次推入同步队列并执行
- 当遇到 setTimeout setInterval,会被推到宏任务队列
- 如果遇到.then，会被当做微任务，被推入微任务队列
- 同步队列执行完毕，然后去微任务取任务，直到微任务队列清空。然后检查宏任务队列，去宏队列取任务，并且每一个宏任务执行完毕都会去微任务队列跑一遍，看看有没有新的微任务，有的话再把微任务清空。这样依次循环。

同步代码—微任务（要全部执行）—>宏任务（执行一个）—>微任务（全部执行）—>宏任务（执行一个）

详细移步这里：[一道关于 JS 微任务和宏任务的面试题(头条)](<js/node/一道关于JS微任务和宏任务的面试题(头条).md>)

### 3、说下 JS 中的闭包吧（@sw）

### 4、JS 中的继承的几种实现方式，ES5、ES6（@sw）

### 5、节流和防抖（@sw）

### 6、js 中的 sort 方法内部实现原理是什么，使用了什么排序（@hk）

### 7、说一下 JS 的原型链（@hk@sw）

- 所有的函数的**proto**都是指向 Function.prototype，包括普通的方法、Object、Function；

- 所有的普通对象的**proto**都是指向 Object.prototype，包括用 Object 构造函数所创建的对象、函数的 prototype 对象，但不包括 Object 的；

- Object.prototype 对象的**proto**指向 null。

### 8、箭头函数和普通函数的区别（@hk@sw）

- 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象，用 call apply bind 也不能改变 this 指向

- 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。

- 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

- 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

- 箭头函数没有原型对象 prototype

### 9、说下 ES6 中的 Set、Map、WeakSet、WeakMap 对象（@hk）

#### Set

类似于一个数组，他里面每一项值都是唯一的，没有重复的值

```js
let s = new Set();
let arr = [2, 3, 5, 4, 5, 2, 2];
arr.forEach(item =arr.add(item)); //向set添加重复的值for (let i of s) {
  console.log(i);
}
// 2 3 5 4 结果set不会添加重复的值
```

使用场景

- 计算数组的并集

```js
let arr1 = [1, 2, 3];
let arr2 = [3, 4, 5];
let s1 = new Set([...arr1, ...arr2]); //这样就把重复的3去掉了
console.log([...s1]); //这就是并集的结果了
```

- 数组去重

```js
let s = new Set();
let arr = [2, 3, 5, 4, 5, 2, 2];
arr.forEach(item =arr.add(item)); //向set添加重复的值for (let i of s) {
  console.log(i);
}
// 2 3 5 4 结果set不会添加重复的值
```

#### WeakSet

WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

- 首先，WeakSet 的成员只能是对象，而不能是其他类型的值
- 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中

#### Map

Map 类似于对象，也是键值对的集合，但是“键”的范围不限制于字符串，各种类型的值（包括对象）都可以当作键。Map 也可以接受一个数组作为参数，数组的成员是一个个表示键值对的数组。注意 Map 里面也不可以放重复的项。

```js
let map = new Map([["js", "react"]]);
map.set("js", "react"); //看看是否可以放重复的项
map.set("javaScript", "vue");
console.log(map); //Map {'js' ='react','javaScript' ='vue'} 不可以放重复项
```

#### WeakMap

WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。WeakMap 与 Map 的区别有两点。

- 首先，WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名。
- 其次，WeakMap 的键名所指向的对象，不计入垃圾回收机制。
  详细移步[这里](https://es6.ruanyifeng.com/#docs/set-map#WeakSet)

### 10、事件冒泡的顺序

## 📚 vue

### 1、vue 的底层原理，例：如何实现的数据双向绑定，diff 算法的原理（@hk@腾讯云）

## 📚 网络

### 1、http 相关的问题，比如状态码，https 的加密方式等等（@hk）**弱项，下来需要注重加强**

### 2、如何解决浏览器跨域（@腾讯云）

### 3、http2 新特性（@腾讯云）

## 📚 浏览器

### 1、浏览器的缓存机制（@hk）

cookies、sessionStorage、localStorage

区别：从数据的生命周期、数据存储大小、是否参与 http 请求三个方面说

- 数据的生命周期

  cookies：一般由服务端生成，可以通过设置 http 请求头里面的（catch-control）设置数据的过期的时间；

  sessionStorage：浏览器关闭就会清除；

  localStorage：除非手动清除，不然一直存在。

- 数据的存储大小

  cookies：4k 左右；

  sessionStorage：5M 左右；

  localStorage：5M 左右。

- 是否参与 http 请求

  cookies：每次都会携带在请求 header 中，会影响请求性能；

  sessionStorage：不参与；

  localStorage：不参与。

### 2、浏览器渲染原理与过程（@MY）

## 📚 webpack

### 1、webpack 了解多少，loader 和 plugin 的区别（@hk）

- Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。

- Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

- Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。

- Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。

### 2、webpack 打包流程（@腾讯云@MY）

## 📚 性能

## 📚 安全

## 📚 业务

### 1、说一个你最新做的项目吧，你在项目过程中遇到了哪些具体的问题？（@hk@sw）

### 2、服务接口延期了，你如何推进项目进度（@hk）

## 📚 算法

### 1、微信发红包随机数如何计算，10 元发给 5 个人，随机分配（@hk）

### 2、一个人上楼梯，可以一次上一阶，也可以一次上两阶，现在一个 10 阶的楼梯，有多少种上法？（@hk）

### 3、快速排序算法

### 4、有一个数组，比如[1, 2, 3, 5, 7, 9, 11, 12, 13, 15, 19, 21, 25, 27]，任意给一个 k 值，找出数组里面任意两个数字相加等于 k 的组合

```js
// 时间复杂度O(n2)
const fin = [];
const k = 8;
const array = [1, 2, 3, 5, 7, 9, 11, 12, 13, 15, 19, 21, 25, 27];
for (let i = 0; i < array.length; i++) {
  for (let j = i + 1; j < array.length - 1 - i; j++) {
    if (array[i] + array[j] === k) {
      fin.push([array[i], array[j]]);
    }
  }
}
console.log(fin);
```

## 2023.10.24 整理

### 八股

1. 原型及原型链、原型链是什么？为什么用它？

   js 中可以使用构造函数去创建对象，每个构造函数上面有会有一个 prototype 属性，该属性是一个对象，被称为该函数的原型，
   原型对象里面记录了由该构造函数创建的对象所共享的所有属性和方法，然后每一个对象都会有一个指针指向其构造函数中的原型对象，
   当一个对象读取一个属性或者调用一个方法的时候，会先在自己的属性里面寻找，如果找不到就会去自己的原型对象里面查找，然后
   原型对象又有自己的原型对象，就这样一直查找下去，就形成了原型链的概念，原型的主要作用是为了共享属性和方法

2. 闭包

   在一个函数作用域里面使用了另一个函数作用域的值，该函数就形成了一个闭包

3. Promise、then 和 catch 的区别是什么？、为什么有 async 和 await

promise 是异步编程的一种解决方案，它是一个对象，解决了之前 ajax 的地狱回调的编程困境
then 函数的参数有两个函数，通常第二个函数是可选的，是在 promise 内部出错的时候调用的回调函数，
但是和 catch 的区别是，第二个函数不能捕捉到第一个函数中的报错，但是 catch 可以，所以平时开发中
针对 promise 的错误捕捉，一般都是使用 catch
为什么会出现 async 和 await
其实，虽然 promise 解决了低于回调，但是还是要写长长的链式调用，代码可复性其实也不是很友好，所以 async 和 await
就是为了解决这个问题的，使用该关键字，可以异步的代码写的像同步的代码一样

4. 宏任务微任务、setTimeout 执行是宏，还是微任务

js 的任务分为同步任务和异步任务，代码在执行的时候，先执行同步任务队列，当执行过程中遇到宏任务或者微任务的时候，会将任务
推入其对应的异步任务队列，当同步任务执行完毕之后，则去逐一执行微任务，微任务执行完毕之后，执行一个宏任务，然后当该宏任务执行完毕之后则继续在微任务列表里面查看有没有新的微任务，有的话先执行微任务，执行完微任务继续执行宏任务

同步代码—微任务（要全部执行）—>宏任务（执行一个）—>微任务（全部执行）—>宏任务（执行一个）

5. React 生命周期

目前还没有使用过

6. useEffect 的作用

目前还没有使用过

7. 浏览器的渲染流程

```
浏览器的渲染流程可以简单地描述为以下几个步骤：

解析 HTML：浏览器从网络或本地缓存中获取 HTML 文件，并开始解析。解析过程中，浏览器会构建 DOM 树（Document Object Model），将 HTML 标记转化为树形结构的对象。

构建 CSSOM：同时解析 CSS 文件，构建 CSSOM 树（CSS Object Model）。CSSOM 树表示页面中的样式信息，包括选择器、属性和值等。

合成渲染树：将 DOM 树和 CSSOM 树合并，生成渲染树（Render Tree）。渲染树只包含需要显示的元素和其对应的样式信息，不包含隐藏的元素或不可见的元素。

布局计算：根据渲染树的信息，浏览器进行布局计算，确定每个元素在页面中的位置和大小。这个过程也被称为回流（reflow）或布局（layout）。

绘制页面：根据布局计算的结果，浏览器开始绘制页面。它会遍历渲染树，并将每个元素转换为屏幕上的实际像素。这个过程也被称为重绘（repaint）或绘制（paint）。

显示页面：绘制完成后，浏览器将绘制的结果显示在用户的屏幕上，呈现出可见的网页内容。

需要注意的是，以上步骤并不是一次性完成的，而是一个持续的过程。当浏览器接收到新的 HTML、CSS 或 JavaScript 时，可能会触发重新解析、构建渲染树、布局计算和绘制等过程，以更新页面的显示。

此外，为了提高性能，现代浏览器还采取了一些优化措施，如异步加载脚本、懒加载图片、使用缓存等，以加快页面加载和渲染速度。这些优化措施可以减少不必要的网络请求和渲染操作，提升用户体验。
```

8. DOM 解析过程中遇到 script 标签会发生什么？

```
在 DOM 解析过程中，当遇到 <script> 标签时，浏览器会暂停 DOM 的解析，并开始执行脚本。这是因为脚本可能会对 DOM 结构进行修改，而浏览器希望在执行脚本之前先构建完整的 DOM 树。

具体的处理方式取决于 <script> 标签的属性和位置：

如果 <script> 标签带有 async 属性：浏览器会异步加载并执行脚本，不会阻塞 DOM 的解析过程。脚本的加载和执行与 DOM 解析是并行进行的，脚本执行的时机取决于其加载完成的时间。

如果 <script> 标签带有 defer 属性：浏览器会异步加载脚本，但会在 DOM 解析完成后、DOMContentLoaded 事件触发前按照顺序执行脚本。defer 属性保证了脚本的执行顺序与它们在文档中的顺序一致。

如果 <script> 标签没有 async 和 defer 属性：浏览器会同步加载并执行脚本，此时会阻塞 DOM 的解析过程。即使是外部脚本，浏览器也会等待脚本加载完成并执行后再继续解析 DOM。

需要注意的是，由于脚本的执行可能会对 DOM 进行修改，因此如果脚本在执行过程中修改了 DOM，浏览器可能会停止当前的解析过程，并重新开始解析修改后的 DOM。这种情况下，之前解析的部分可能需要重新解析。

为了避免阻塞 DOM 解析，一般推荐将脚本放在 <body> 标签的末尾，或使用 async 或 defer 属性来异步加载脚本。这样可以保证脚本的加载和执行不会阻塞页面的渲染和用户的交互。
```

9. Webpack 的作用、webpack 打包文件名为什么生成 hash(x2)
10. forEach、filter、map 的区别

```
forEach 用于遍历数组并执行回调函数，没有返回值；filter 用于根据条件筛选出符合条件的元素，返回一个新数组；map 用于对数组中的每个元素执行操作并返回一个新数组，新数组的元素是操作后的结果。
```

11. 跨域以及跨域的解决方案

```
JSONP（JSON with Padding）：JSONP 是一种利用 <script> 标签可以跨域加载资源的特性来实现跨域请求的方法。通过在请求 URL 中添加一个回调函数的参数，服务端返回的数据会被包裹在该回调函数中，从而实现跨域数据的获取。

CORS（Cross-Origin Resource Sharing）：CORS 是一种现代浏览器支持的跨域解决方案。它通过在服务器端设置响应头来控制是否允许跨域访问。服务器端需要设置 Access-Control-Allow-Origin 头来指定允许访问的源，也可以设置其他的 CORS 相关头来控制请求的方法、头信息等。

代理服务器：可以通过在自己的服务器上设置一个代理，将跨域请求转发到目标服务器上，然后再将响应返回给前端。前端只需要向自己的服务器发起请求，避免了直接跨域访问的问题。
```

12. TS 接触过吗？

没有

13. 防抖和节流技术在项目中的使用，应用场景

```
地图在快速拖动或者使用鼠标滚轮放大缩小的时候，需要频繁的给渲染服务发送请求，导致没必要的数据交互服务，导致操作卡顿，所以
这里使用了防抖技术，在最后一次拖动或者缩放之后在请求数据

```

14. 如何解决回调地狱问题的？

使用 Promise

15. 图片懒加载怎样实现

- 直接使用 elementui 的 el-image 组件，配置上其 lazy 属性即可
- 使用 vue 的 lazyload 插件

16. 怎么用，以及为什么要用 redux

目前没使用过

17. 受控组件和非受控组件的区别

没有使用过 react

18. 高阶组件
19. html 文件不生产 hash 怎么做缓存（x2）
20. 一句话描述 vue、react 与 jquery 开发的区别
21. vue 的 key 的作用，为什么不能用数组的下标做 key

22. 观察者模式与发布订阅模式的区别

    观察者模式，多用于单个应用内部，没有第三方来实现调度。 定义了对象之间的一对多关系。
    发布订阅模式是观察者模式的一种变种，发布者和订阅者相互之间不知道彼此的存在，他们通过调度中心联系到彼此。事件名称一直是他们能联系彼此的条件。多应用于将多层透传通信方式扁平化。

23. 函数柯里化的作用---参数复用，延迟执行
24. 强缓存和协商缓存的区别
25. 状态码，404 到底是在请求服务器之后，发现没找到资源，服务器返回的 404；还是服务器挂了（500），客户端返回的 404

```css
<style>
    .container {
        display: flex;
        justify-content: space-between;
    }

    .center {
        flex: 1;
        background-color: seagreen;
        height: 400px;
    }

    .left,
    .right {
        flex: 0 0 200px;
        background-color: sienna;
        height: 400px;
    }
</style>
```

27. 字符串计数，用 map 实现，延伸一下求最多的字符，统计 map 中 value 最大的。

```js
function countChar(str) {
  const charMap = new Map();
  for (const char of str) {
    charMap.set(char, charMap.get(char) + 1 || 1);
  }
  return charMap;
}
```

28. vue2 和 vue3 区别。可从用法到源码都说了一遍。

    - 组合式 API
    - 组件中支持多根节点
    - 支持异步组件
    - 响应式原理也发生了变化，vue2 使用的是 Objec.defineProperty,但是 vue3 使用的是 Proxy

29. vue 实现数据响应。说了下 watch。

vue2 中使用 Object.defineProperty()方法实现乐响应式，但是该方法有一个局限性，那就是对对象属性的新增和删除
以及数组的变化是没有办法检测的，所以针对数组，vue2 专门修改了数组中可以改变数组自身的几个方法：push，pop，shift，unshift，splice，sort，reverse，针对对象的属性的增删也是提供了单独的方式去处理

但是 vue3 中，使用了 es 最新的 proxy 方法去实现了响应式，该方法就没有上述 vue2 中的问题

30. 说下 watch 和 compute 区别，秒了。

computed 擅长处理的场景：一个数据受多个数据影响；watch 擅长处理的场景：一个数据影响多个数据。

- 功能上：computed 是计算属性，watch 是监听一个值的变化，然后执行对应的回调。
- 是否调用缓存：computed 支持缓存，只有依赖数据发生改变,才会重新进行计算;而 watch 不支持缓存，数据变,直接会触发相应的操作。
- 是否调用 return：computed 中的函数必须要用 return 返回，watch 中的函数不是必须要用 return。
- computed 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化;而 watch 支持异步。
- computed 默认第一次加载的时候就开始监听；watch 默认第一次加载不做监听，如果需要第一次加载做监听，添加 immediate 属性，设置为 true（immediate:true）

31. es6 有哪些新特性，项目中用了。说了七八个。

- 块级作用域
- 箭头函数
- 解构赋值
- 默认参数
- 扩展运算符
- 模板字符串
- 类和模块
- promise

32. 实现左边固定，右边自适应布局，用 flex 布局怎么实现
33. 了解 slot 插槽么？

在定义子组件的时候，为父组件使用 solt 标签留坑，插槽位置，允许父组件在使用子组件的可以将自定义的
标签，组件等传给子组件，插槽有这么几种

- 默认插槽，就是子组件里面只有一个位置，父组件传入的内容默认就放在这个位置
- 具名插槽，就是子组件内部定义了多个插槽的时候，父组件在传入的时候需要通过名称分别对应不同的插槽位置
- 作用域插槽，可以为预留的插槽绑定数据

### 算法/手写

1. 手写深拷贝

```js
function deepCopy(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  let newObj = new obj.constructor();
  for (const key in obj) {
    if (Object.hasOwnProperty.call(obj, key)) {
      newObj[key] = deepCopy(obj[key]);
    }
  }
  return newObj;
}
```

2. 手写冒泡排序

```js
function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        var num = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = num;
      }
    }
  }
  return arr;
}
```

3. 手写防抖、节流

```js
// 防抖
function debounce(fn, wait) {
  let timeouter = null;
  return function () {
    const _this = this;
    const args = arguments;
    if (timeouter) {
      clearTimeout(timeouter);
    }

    timeouter = setTimeout(function () {
      fn.apply(_this, args);
    }, wait);
  };
}

// 节流
function throttle(fn, wait) {
  let timeouter = null;
  return function () {
    const _this = this;
    const args = arguments;
    if (!timeouter) {
      timeouter = setTimeout(function () {
        fn.apply(_this, args);
        timeouter = null;
      }, wait);
    }
  };
}
```

4. 快速排序

```js
function quickSort(arr) {
  if (arr.length <= 1) return arr;
  const left = [];
  const right = [];
  const mid = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < mid) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return [...quickSort(left), mid, ...quickSort(right)];
}
```

5. 进一步=>直接在原数组上进行排序，不占用别的空间如何实现

```js
// 使用选择排序
function chooseSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] > arr[j]) {
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
  }
}
```

6. 手写 delay
7. 手写拍平数组

```js
Array.prototype.flattenArray = function () {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    if (Array.isArray(this[i])) {
      result = result.concat(flattenArray(this[i]));
    } else {
      result.push(this[i]);
    }
  }
  return result;
};
```

8. 插入排序

```js
Array.prototype.myinsertionSort = function () {
  for (let i = 1; i < this.length; i++) {
    let temp = this[i];
    let j = i;
    for (j; this[j - 1] > temp; j--) {
      this[j] = this[j - 1];
    }
    this[j] = temp;
  }
  console.log(this);
};
```

### 开放

1. 为什么要来前端岗位？
2. 从整体的角度来说一下前端技术？(这种开放题反而有点不知道怎么回答)
3. canvas 内部有 10 个元素，知道 10 个元素的左上角坐标和宽高，如何对 10 个元素进行事件监听

```
要对 canvas 内的元素进行事件监听，需要借助一些额外的技术手段，因为 canvas 本身并不提供 DOM 元素的结构，无法直接对每个元素进行事件监听。

一种常见的做法是在 canvas 上监听鼠标事件，并通过计算鼠标位置与元素位置的关系来确定是否触发了元素的事件
```

4. 一个好的模块需要具备哪些方面

```
一个好的模块应该具备单一职责、高内聚性、低耦合性、可重用性、易于测试、可扩展性以及良好的文档和注释等特点。这些特点可以帮助提高模块的质量、可维护性和可复用性，从而提升整个系统的开发效率和质量。
```

5. 如何看待技术与业务的关系

```
技术和业务是密不可分的，技术是为业务服务的手段，而业务则是技术的驱动力。在现代企业中，技术已经成为了企业竞争的重要因素之一，技术与业务的关系越来越紧密。

首先，技术是业务的基础。没有技术的支持，业务无法顺利进行。例如，在电商领域，技术的支持是电商平台能够实现高并发、快速响应、安全稳定等特性的关键。而在金融领域，技术的支持是保证交易安全、数据准确、系统稳定的前提。

其次，业务也是技术发展的推动力。业务需求的不断变化和升级，促使技术不断创新和进步。例如，随着人工智能技术的发展，各行各业都在探索如何将 AI 技术应用到业务中，从而提升效率、降低成本、提高用户体验等。

最后，技术和业务的关系是相互促进的。技术的发展为业务提供了更多的可能性和空间，而业务的需求也推动了技术的不断创新和发展。在实际工作中，技术人员需要深入了解业务需求，为业务提供最优的技术方案；而业务人员也需要了解技术的发展趋势和应用场景，为技术提供更多的实践场景和需求。

因此，技术和业务是相互依存、相互促进的关系。只有将二者紧密结合起来，才能够实现企业的长期发展和竞争优势。
```

6. 自己是技术负责人如果自己觉得方案 A 好，但主管觉得 B 好，最终会上哪套方案

```
在这种情况下，作为技术负责人，你可以积极地与主管沟通，解释和阐述你认为方案 A 的优势和价值，并提供相关的技术分析和数据支持。通过充分的沟通和合作，你可以帮助主管更好地理解你的观点，并共同决策最终选择哪个方案。但最终决策权仍然掌握在主管手中，你需要尊重并接受他们的最终决策。
```

7. 公司相关场景题，大概就是地图上要展示海量数据，发散性思维如何进行优化，前端后端均可

```
展示海量数据的地图是一个挑战性的任务，需要考虑如何优化性能和用户体验。以下是一些发散性思维的优化方法：

数据聚合：考虑对数据进行聚合，以减少在地图上展示的数据量。可以使用聚合算法（如网格聚合、热力图等）将相邻的数据点合并为一个代表点，从而减少数据量并保留整体趋势。

渐进式加载：采用渐进式加载的方式，先加载地图的基础信息和部分数据，然后根据用户的操作或视野范围逐步加载更多的数据。这样可以提高地图的响应速度，避免一次性加载大量数据导致的性能问题。

瓦片化技术：将地图切分为多个瓦片，并根据用户的视野范围和缩放级别加载相应的瓦片。这样可以有效减少每次加载的数据量，并提高地图的渲染性能。

数据过滤和筛选：根据用户的需求和关注点，提供数据过滤和筛选的功能，让用户可以根据自己的需求选择展示的数据类型、时间范围、区域等条件，从而减少展示的数据量。

数据可视化技术：使用合适的数据可视化技术，将海量数据以更直观、简洁的方式展示在地图上。比如使用聚类、热力图、密度图等技术来表达数据的分布和趋势，提供更好的用户体验。

前端性能优化：在前端开发中，采用一些性能优化的技术，如图片懒加载、异步加载、缓存等，可以提高地图的加载速度和响应性能。

后端数据处理：对于海量数据，可以考虑在后端进行数据处理和压缩，以减少数据传输和加载的时间。可以采用数据压缩算法、索引技术等来提高数据的存储和检索效率。

这些优化方法可以结合使用，根据具体的需求和场景进行调整和实施。通过合理的数据处理和展示方式，可以提高地图展示海量数据时的性能和用户体验。
```
