## 📚 Javascript

### 1、如何直接在原数组里面删除偶数？注：直接在原数组上操作，不产生新的数组！（@sw）

### 2、说下 JS 中的事件循环机制

JS 的任务分为同步任务和异步任务：

- 任务队列分为同步任务队列和异步任务队列；
- 代码执行时，遇到同步代码，会被直接推入同步任务队列并依次执行；
- 遇到异步代码（如 setTimeout、setInteval）会被直接推入异步任务队列；
- 当同步任务队列执行完毕，这个时候异步任务队列的任务会被一次推入同步任务队列并依次执行

JS 的任务队列分为：
宏任务：setTimeout setInterval
微任务：Promise.then 方法。注意 new Promise()的时候是同步的，会立即执行。
注意：现在有三个队列：同步队列（也称为执行栈）、宏任务队列、微任务队列
所以，针对这种机制，js 的事件循环机制应该是这样的：

- 遇到同步代码，依次推入同步队列并执行
- 当遇到 setTimeout setInterval,会被推到宏任务队列
- 如果遇到.then，会被当做微任务，被推入微任务队列
- 同步队列执行完毕，然后去微任务取任务，直到微任务队列清空。然后检查宏任务队列，去宏队列取任务，并且每一个宏任务执行完毕都会去微任务队列跑一遍，看看有没有新的微任务，有的话再把微任务清空。这样依次循环。

同步代码—微任务（要全部执行）—>宏任务（执行一个）—>微任务（全部执行）—>宏任务（执行一个）

详细移步这里：[一道关于 JS 微任务和宏任务的面试题(头条)](<js/node/一道关于JS微任务和宏任务的面试题(头条).md>)

### 3、说下 JS 中的闭包吧（@sw）

### 4、JS 中的继承的几种实现方式，ES5、ES6（@sw）

### 5、节流和防抖（@sw）

### 6、js 中的 sort 方法内部实现原理是什么，使用了什么排序（@hk）

### 7、说一下 JS 的原型链（@hk@sw）

- 所有的函数的**proto**都是指向 Function.prototype，包括普通的方法、Object、Function；

- 所有的普通对象的**proto**都是指向 Object.prototype，包括用 Object 构造函数所创建的对象、函数的 prototype 对象，但不包括 Object 的；

- Object.prototype 对象的**proto**指向 null。

### 8、箭头函数和普通函数的区别（@hk@sw）

- 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象，用 call apply bind 也不能改变 this 指向

- 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。

- 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

- 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

- 箭头函数没有原型对象 prototype

### 9、说下 ES6 中的 Set、Map、WeakSet、WeakMap 对象（@hk）

#### Set

类似于一个数组，他里面每一项值都是唯一的，没有重复的值

```js
let s = new Set();
let arr = [2, 3, 5, 4, 5, 2, 2];
arr.forEach(item =arr.add(item)); //向set添加重复的值for (let i of s) {
  console.log(i);
}
// 2 3 5 4 结果set不会添加重复的值
```

使用场景

- 计算数组的并集

```js
let arr1 = [1, 2, 3];
let arr2 = [3, 4, 5];
let s1 = new Set([...arr1, ...arr2]); //这样就把重复的3去掉了
console.log([...s1]); //这就是并集的结果了
```

- 数组去重

```js
let s = new Set();
let arr = [2, 3, 5, 4, 5, 2, 2];
arr.forEach(item =arr.add(item)); //向set添加重复的值for (let i of s) {
  console.log(i);
}
// 2 3 5 4 结果set不会添加重复的值
```

#### WeakSet

WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

- 首先，WeakSet 的成员只能是对象，而不能是其他类型的值
- 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中

#### Map

Map 类似于对象，也是键值对的集合，但是“键”的范围不限制于字符串，各种类型的值（包括对象）都可以当作键。Map 也可以接受一个数组作为参数，数组的成员是一个个表示键值对的数组。注意 Map 里面也不可以放重复的项。

```js
let map = new Map([["js", "react"]]);
map.set("js", "react"); //看看是否可以放重复的项
map.set("javaScript", "vue");
console.log(map); //Map {'js' ='react','javaScript' ='vue'} 不可以放重复项
```

#### WeakMap

WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。WeakMap 与 Map 的区别有两点。

- 首先，WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名。
- 其次，WeakMap 的键名所指向的对象，不计入垃圾回收机制。
  详细移步[这里](https://es6.ruanyifeng.com/#docs/set-map#WeakSet)

### 10、事件冒泡的顺序

## 📚 vue

### 1、vue 的底层原理，例：如何实现的数据双向绑定，diff 算法的原理（@hk@腾讯云）

## 📚 网络

### 1、http 相关的问题，比如状态码，https 的加密方式等等（@hk）**弱项，下来需要注重加强**

### 2、如何解决浏览器跨域（@腾讯云）

### 3、http2 新特性（@腾讯云）

## 📚 浏览器

### 1、浏览器的缓存机制（@hk）

cookies、sessionStorage、localStorage

区别：从数据的生命周期、数据存储大小、是否参与 http 请求三个方面说

- 数据的生命周期

  cookies：一般由服务端生成，可以通过设置 http 请求头里面的（catch-control）设置数据的过期的时间；

  sessionStorage：浏览器关闭就会清除；

  localStorage：除非手动清除，不然一直存在。

- 数据的存储大小

  cookies：4k 左右；

  sessionStorage：5M 左右；

  localStorage：5M 左右。

- 是否参与 http 请求

  cookies：每次都会携带在请求 header 中，会影响请求性能；

  sessionStorage：不参与；

  localStorage：不参与。

### 2、浏览器渲染原理与过程（@MY）

## 📚 webpack

### 1、webpack 了解多少，loader 和 plugin 的区别（@hk）

- Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。

- Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

- Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。

- Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。

### 2、webpack 打包流程（@腾讯云@MY）

## 📚 性能

## 📚 安全

## 📚 业务

### 1、说一个你最新做的项目吧，你在项目过程中遇到了哪些具体的问题？（@hk@sw）

### 2、服务接口延期了，你如何推进项目进度（@hk）

## 📚 算法

### 1、微信发红包随机数如何计算，10 元发给 5 个人，随机分配（@hk）

### 2、一个人上楼梯，可以一次上一阶，也可以一次上两阶，现在一个 10 阶的楼梯，有多少种上法？（@hk）

### 3、快速排序算法

### 4、有一个数组，比如[1, 2, 3, 5, 7, 9, 11, 12, 13, 15, 19, 21, 25, 27]，任意给一个 k 值，找出数组里面任意两个数字相加等于 k 的组合

```js
// 时间复杂度O(n2)
const fin = [];
const k = 8;
const array = [1, 2, 3, 5, 7, 9, 11, 12, 13, 15, 19, 21, 25, 27];
for (let i = 0; i < array.length; i++) {
  for (let j = i + 1; j < array.length - 1 - i; j++) {
    if (array[i] + array[j] === k) {
      fin.push([array[i], array[j]]);
    }
  }
}
console.log(fin);
```

## 2023.10.24 整理

### 八股

1. 原型及原型链、原型链是什么？为什么用它？

   js 中可以使用构造函数去创建对象，每个构造函数上面有会有一个 prototype 属性，该属性是一个对象，被称为该函数的原型，
   原型对象里面记录了由该构造函数创建的对象所共享的所有属性和方法，然后每一个对象都会有一个指针指向其构造函数中的原型对象，
   当一个对象读取一个属性或者调用一个方法的时候，会先在自己的属性里面寻找，如果找不到就会去自己的原型对象里面查找，然后
   原型对象又有自己的原型对象，就这样一直查找下去，就形成了原型链的概念，原型的主要作用是为了共享属性和方法

2. 闭包

   在一个函数作用域里面使用了另一个函数作用域的值，该函数就形成了一个闭包

3. Promise、then 和 catch 的区别是什么？、为什么有 async 和 await

promise 是异步编程的一种解决方案，它是一个对象，解决了之前 ajax 的地狱回调的编程困境
then 函数的参数有两个函数，通常第二个函数是可选的，是在 promise 内部出错的时候调用的回调函数，
但是和 catch 的区别是，第二个函数不能捕捉到第一个函数中的报错，但是 catch 可以，所以平时开发中
针对 promise 的错误捕捉，一般都是使用 catch
为什么会出现 async 和 await
其实，虽然 promise 解决了低于回调，但是还是要写长长的链式调用，代码可复性其实也不是很友好，所以 async 和 await
就是为了解决这个问题的，使用该关键字，可以异步的代码写的像同步的代码一样

4. 宏任务微任务、setTimeout 执行是宏，还是微任务

js 的任务分为同步任务和异步任务，代码在执行的时候，先执行同步任务队列，当执行过程中遇到宏任务或者微任务的时候，会将任务
推入其对应的异步任务队列，当同步任务执行完毕之后，则去逐一执行微任务，微任务执行完毕之后，执行一个宏任务，然后当该宏任务执行完毕之后则继续在微任务列表里面查看有没有新的微任务，有的话先执行微任务，执行完微任务继续执行宏任务

同步代码—微任务（要全部执行）—>宏任务（执行一个）—>微任务（全部执行）—>宏任务（执行一个）

5. React 生命周期

目前还没有使用过

6. useEffect 的作用

目前还没有使用过

7. 浏览器的渲染流程
8. DOM 解析过程中遇到 script 标签会发生什么？
9. Webpack 的作用、webpack 打包文件名为什么生成 hash(x2)
10. forEach、filter、map 的区别
11. 跨域以及跨域的解决方案
12. TS 接触过吗？

没有

13. 防抖和节流技术在项目中的使用，应用场景

地图在快速拖动或者使用鼠标滚轮放大缩小的时候，需要频繁的给渲染服务发送请求，导致没必要的数据交互服务，导致操作卡顿，所以
这里使用了防抖技术，在最后一次拖动或者缩放之后在请求数据

14. 如何解决回调地狱问题的？

使用 Promise

15. 图片懒加载怎样实现
16. 怎么用，以及为什么要用 redux

目前没使用过

17. 受控组件和非受控组件的区别
18. 高阶组件
19. html 文件不生产 hash 怎么做缓存（x2）
20. 一句话描述 vue、react 与 jquery 开发的区别
21. vue 的 key 的作用，为什么不能用数组的下标做 key
22. 观察者模式与发布订阅模式的区别
23. 函数柯里化的作用---参数复用，延迟执行
24. 强缓存和协商缓存的区别
25. 状态码，404 到底是在请求服务器之后，发现没找到资源，服务器返回的 404；还是服务器挂了（500），客户端返回的 404
26. 实现两栏布局，说了三种
27. 字符串计数，用 map 实现，延伸一下求最多的字符，统计 map 中 value 最大的。
28. vue2 和 vue3 区别。可从用法到源码都说了一遍。
29. vue 实现数据响应。说了下 watch。
30. 说下 watch 和 compute 区别，秒了。
31. es6 有哪些新特性，项目中用了。说了七八个。
32. 实现左边固定，右边自适应布局，用 flex 布局怎么实现
33. 了解 slot 插槽么？

在定义子组件的时候，为父组件使用 solt 标签留坑，插槽位置，允许父组件在使用子组件的可以将自定义的
标签，组件等传给子组件，插槽有这么几种

- 默认插槽，就是子组件里面只有一个位置，父组件传入的内容默认就放在这个位置
- 具名插槽，就是子组件内部定义了多个插槽的时候，父组件在传入的时候需要通过名称分别对应不同的插槽位置
- 作用域插槽，可以为预留的插槽绑定数据

### 算法/手写

1. 手写深拷贝

```js
function deepCopy(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  let newObj = new obj.constructor();
  for (const key in obj) {
    if (Object.hasOwnProperty.call(obj, key)) {
      newObj[key] = deepCopy(obj[key]);
    }
  }
  return newObj;
}
```

2. 手写冒泡排序

```js
function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        var num = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = num;
      }
    }
  }
  return arr;
}
```

3. 手写防抖、节流

```js
// 防抖
function debounce(fn, wait) {
  let timeouter = null;
  return function () {
    const _this = this;
    const args = arguments;
    if (timeouter) {
      clearTimeout(timeouter);
    }

    timeouter = setTimeout(function () {
      fn.apply(_this, args);
    }, wait);
  };
}

// 节流
function throttle(fn, wait) {
  let timeouter = null;
  return function () {
    const _this = this;
    const args = arguments;
    if (!timeouter) {
      timeouter = setTimeout(function () {
        fn.apply(_this, args);
        timeouter = null;
      }, wait);
    }
  };
}
```

4. 快速排序

```js
function quickSort(arr) {
  if (arr.length <= 1) return arr;
  const left = [];
  const right = [];
  const mid = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < mid) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return [...quickSort(left), mid, ...quickSort(right)];
}
```

5. 进一步=>直接在原数组上进行排序，不占用别的空间如何实现

```js
// 使用选择排序
function chooseSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] > arr[j]) {
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
  }
}
```

6. 手写 delay
7. 手写拍平数组

```js
Array.prototype.flattenArray = function () {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    if (Array.isArray(this[i])) {
      result = result.concat(flattenArray(this[i]));
    } else {
      result.push(this[i]);
    }
  }
  return result;
};
```

8. 插入排序

```js
Array.prototype.myinsertionSort = function () {
  for (let i = 1; i < this.length; i++) {
    let temp = this[i];
    let j = i;
    for (j; this[j - 1] > temp; j--) {
      this[j] = this[j - 1];
    }
    this[j] = temp;
  }
  console.log(this);
};
```

### 开放

1. 为什么要来前端岗位？
2. 从整体的角度来说一下前端技术？(这种开放题反而有点不知道怎么回答)
3. canvas 内部有 10 个元素，知道 10 个元素的左上角坐标和宽高，如何对 10 个元素进行事件监听
4. 一个好的模块需要具备哪些方面
5. 如何看待技术与业务的关系
6. 自己是技术负责人如果自己觉得方案 A 好，但主管觉得 B 好，最终会上哪套方案
7. 公司相关场景题，大概就是地图上要展示海量数据，发散性思维如何进行优化，前端后端均可
